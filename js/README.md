# JavaScript 주요 개념 정리

## 1. 이벤트 버블링과 캡처링

### **이벤트 흐름**
HTML 요소에서 발생하는 이벤트는 다음 3단계를 거칩니다:
1. **캡처링 단계**: 이벤트가 상위 요소에서 하위 요소로 전파됩니다.
2. **타깃 단계**: 이벤트가 실제 타깃 요소에 도달합니다.
3. **버블링 단계**: 이벤트가 타깃 요소에서 상위 요소로 전파됩니다.

### **캡처링과 버블링의 차이**
- **캡처링**: 상위 요소에서 하위 요소로 이벤트가 전달되는 과정입니다. `addEventListener` 호출 시 세 번째 인자로 `{ capture: true }`를 설정하면 캡처링 단계에서 이벤트를 처리할 수 있습니다[3][6].
- **버블링**: 타깃 요소에서 시작해 상위 요소로 이벤트가 전달되는 과정입니다. 기본적으로 대부분의 브라우저는 버블링 방식을 사용합니다[6][9].

## 2. 이벤트 위임 (Event Delegation)

### **개념**
이벤트 위임은 하위 요소 각각에 이벤트 핸들러를 추가하는 대신, 상위 요소에 핸들러를 추가하여 하위 요소의 이벤트를 처리하는 방식입니다. 이는 **이벤트 버블링**을 활용한 패턴입니다[4][7].

### **장점**
- 메모리 사용 감소: 많은 하위 요소에 각각 핸들러를 추가할 필요가 없습니다.
- 동적 요소 처리 용이: 새롭게 추가된 하위 요소도 별도의 핸들러 추가 없이 이벤트를 처리할 수 있습니다[13][19].

```
<div id="menu">
  <button class="item">Item 1</button>
   <button class="item">Item 2</button>
 </div>
<script>
const menu = document.querySelector("#menu");
menu.addEventListener("click", (event) => {
   if (event.target.classList.contains("item")) {
    alert(`${event.target.innerText} clicked`);
  }
});
</script>
```

## 3. Promise 객체

### **개념**
`Promise`는 JavaScript에서 비동기 작업을 처리하기 위한 객체입니다. 작업의 성공 또는 실패 상태를 나타내며, 다음 세 가지 상태를 가질 수 있습니다:
1. **Pending**: 초기 상태, 이행(fulfilled) 또는 거부(rejected)되지 않음.
2. **Fulfilled**: 작업이 성공적으로 완료됨.
3. **Rejected**: 작업이 실패함[8][20].

### **사용법**
- `then()`: 작업 성공 시 호출되는 핸들러 등록.
- `catch()`: 작업 실패 시 호출되는 핸들러 등록.
- `finally()`: 성공 여부와 관계없이 항상 실행되는 핸들러 등록

### 3.2 주요 기능
- **Promise.all**: 병렬 처리 (모든 작업 완료 시 결과 반환)
- - **Promise.race**: 경쟁 처리 (가장 빠른 결과 반환)
 
### 3.3 주의사항
- `forEach` 대신 `for...of` 사용 권장 (순차적 실행 보장)



## 4. JavaScript의 불변성
JavaScript에서 불변성은 특정 메모리 주소에 할당된 데이터가 변하지 않는 성질을 말합니다. 원시 데이터 타입(문자, 숫자, 불리언 등)은 기본적으로 불변성을 가지고 있습니다. 예를 들어, 문자열은 한 번 생성되면 변경할 수 없기 때문에 새로운 값을 할당하면 기존 값이 아닌 새로운 메모리 공간에 저장됩니다. :
반면, 객체나 배열과 같은 참조 데이터 타입은 가변성을 가지고 있습니다. 이는 특정 메모리 주소에 저장된 데이터가 변경될 수 있다는 뜻입니다. 이러한 가변성 때문에 데이터의 변화를 추적하거나 예측하기 어려운 경우가 많습니다. 따라서 객체나 배열의 데이터를 변경하지 않고 새로운 객체를 생성하는 방식으로 불변성을 유지하는 것이 중요합니다. 이를 위해 깊은 복사를 사용하거나, Immer.js와 같은 불변성 관리 라이브러리를 활용하기도 합니다.:


---

## 5. 클로저(Closure)

JavaScript에서 클로저는 함수가 선언될 당시의 렉시컬 스코프(Lexical Scope)를 기억하고 있다가, 함수가 호출될 때 그 스코프 내 변수에 접근할 수 있는 기능입니다. 클로저는 외부 함수 내에서 선언된 내부 함수가 외부 함수의 변수에 접근할 수 있도록 하며, 외부 함수 실행이 끝난 이후에도 내부 함수는 여전히 외부 변수에 접근할 수 있습니다.

클로저는 주로 데이터 은닉과 캡슐화를 구현하는 데 사용됩니다. 예를 들어, 특정 변수나 데이터를 외부에서 직접 접근하지 못하도록 보호하면서도 내부 함수에서는 해당 데이터에 접근할 수 있도록 할 수 있습니다. 또한 클로저는 상태를 유지하거나 고차 함수 패턴에서 자주 활용됩니다.
```
function createCounter() {
  let count = 0; // 클로저에 캡슐화된 변수
  return {
    increment: () => ++count,
    getCount: () => count,
  };
}

const counter = createCounter();
console.log(counter.increment()); // 1
```

---




